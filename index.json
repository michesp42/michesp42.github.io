[{"categories":["notes","tutorial"],"content":"CompTIA Linux+ Exam Objective 1.1.3 Info This article is my third note for Shawn Powers’ tutorial playlist on the CompTIA Linux+ Exam. The notes starts here. ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:0:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"Block and character devices Block and character devices are ways to get data in and out of a Linux system, i.e. how Linux communicates with things like a hard drive (which is a block device) and a serial port (which is a character device). The diffference between block and characters devices is that the former use buffers and caches to transfer large amounts of data (e.g., storage devices) while the latter literally transfer streams of characters (e.g., a stream of null characters) without buffering. To make an analogy, if water is data then block devices are like pails where you can store water first (buffering) before transfering it while character devices are like fire hose (to copy Shawn Powers’ analogy) which transfers water in a gushing, continuous stream. ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:1:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"Where devices live in Linux As specified in the Linux filesystem standard devices are located in /dev. Listing out the files under my /dev folder shows something like this $ ls -F /dev acpi_thermal_rel disk/ hidraw2 mei0 nvme0n1 rfkill tty tty18 tty28 tty38 tty48 tty58 ttyS1 ttyS2 ttyS3 uinput vcs6 vcsu1 vhost-vsock autofs dma_heap/ hpet mem nvme0n1p1 rtc@ tty0 tty19 tty29 tty39 tty49 tty59 ttyS10 ttyS20 ttyS30 urandom vcs7 vcsu2 video0 block/ dri/ hugepages/ mqueue/ nvme0n1p2 rtc0 tty1 tty2 tty3 tty4 tty5 tty6 ttyS11 ttyS21 ttyS31 usb/ vcsa vcsu3 video1 btrfs-control drm_dp_aux0 hwrng mtd0 nvme0n1p3 shm/ tty10 tty20 tty30 tty40 tty50 tty60 ttyS12 ttyS22 ttyS4 userio vcsa1 vcsu4 watchdog bus/ fb0 input/ mtd0ro nvram snapshot tty11 tty21 tty31 tty41 tty51 tty61 ttyS13 ttyS23 ttyS5 v4l/ vcsa2 vcsu5 watchdog0 char/ fd@ kmsg mtd1 port snd/ tty12 tty22 tty32 tty42 tty52 tty62 ttyS14 ttyS24 ttyS6 vcs vcsa3 vcsu6 wmi/ console full kvm mtd1ro ppp stderr@ tty13 tty23 tty33 tty43 tty53 tty63 ttyS15 ttyS25 ttyS7 vcs1 vcsa4 vcsu7 zero core@ fuse log@ net/ psaux stdin@ tty14 tty24 tty34 tty44 tty54 tty7 ttyS16 ttyS26 ttyS8 vcs2 vcsa5 vfio/ cpu/ gpiochip0 loop-control ng0n1 ptmx stdout@ tty15 tty25 tty35 tty45 tty55 tty8 ttyS17 ttyS27 ttyS9 vcs3 vcsa6 vga_arbiter cpu_dma_latency hidraw0 mapper/ null pts/ tpm0 tty16 tty26 tty36 tty46 tty56 tty9 ttyS18 ttyS28 udmabuf vcs4 vcsa7 vhci cuse hidraw1 media0 nvme0 random tpmrm0 tty17 tty27 tty37 tty47 tty57 ttyS0 ttyS19 ttyS29 uhid vcs5 vcsu vhost-net Some of the files I recognize from the list are nvme0n1 which is my SSD, nvme0n1p1, nvme0n1p1, and nvme0n1p3 are partitions of the SSD, are stdin, stderr, and stderr are three data streams which we can use for piping and redirection. Tip To know which are devices are block and character devices in /dev you can use the long listing format of ls like so $ ls -l /dev ... crw------- 1 root root 239, 0 Aug 8 16:25 nvme0 brw-rw---- 1 root disk 259, 0 Aug 8 16:25 nvme0n1 ... The first character of the list is the indicator – c is for character devices and b is for block devices. Some important character devices ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:2:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"/dev/zero and /dev/null Two character devices that are very important and used a lot that they deserve to be mentioned are /dev/zero and /dev/null. /dev/zero is simply like a source of the null character \\0 (not to be confused with the character for the number 0). One use of /dev/zero for example is to erase a disk drive using the dd command dd if=/dev/zero of=/dev/sda count=100000 In the example above, we used /dev/zero as the input file for dd to zero out the disk drive /dev/sda. On the other hand, /dev/null, also known as the bitbucket, is a write-only filesystem where you write data to that you want to be lost forever. If data is to light then /dev/null is to black hole. It is commonly use as the redirection destination of data streams, for example $ cat nonexisting_file.txt cat: nonexisting.file: No such file or directory $ cat nonexisting_file.txt 2\u003e/dev/null $ Trying to display the contents of a file that does not exist is an error but when redirecting stderr to /dev/nullshows no error. ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:3:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"/dev/urandom and /dev/random Another two character devices that deserve our attention are /dev/urandom and /dev/random. Both of them provide stream of random characters. The difference between /dev/random and /dev/urandom is that when you query /dev/random it will not return anything until it has determined that enough entropy has been built up in the system while /dev/urandom always returns immediately regardless of the amount of entropy in the system. Knowing your hardware In this section, we’ll familiarize ourselves with some tools to get hard information in your system. ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:4:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"lspci The lspci command shows a list PCI devices. For instance if I use lspci in my computer it will show something like $ lspci 0000:00:00.0 Host bridge: Intel Corporation Device 9a04 (rev 01) 0000:00:02.0 VGA compatible controller: Intel Corporation Device 9a78 (rev 01) 0000:00:04.0 Signal processing controller: Intel Corporation TigerLake-LP Dynamic Tuning Processor Participant (rev 01) 0000:00:0a.0 Signal processing controller: Intel Corporation Tigerlake Telemetry Aggregator Driver (rev 01) 0000:00:0e.0 RAID bus controller: Intel Corporation Volume Management Device NVMe RAID Controller ... ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:5:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"lsusb The lsusb command lists out USB devices. Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 0c45:671e Microdia Integrated_Webcam_HD Bus 001 Device 003: ID 8087:0aaa Intel Corp. Bluetooth 9460/9560 Jefferson Peak (JfP) Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:6:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"dmidecode Its man page says, dmidecode is a tool for dumping a computer’s DMI table contents in a human-readable format. When I ran the command it indeed dumped so much information that it could have filled up a few pages of paper. However, we can specify using flags what specific information we want. For example to get processor information we run dmidecode -t processor or to get memory information dmidecode -t memory. Running the last command in my system displayed $ sudo dmidecode -t memory # dmidecode 3.4 Getting SMBIOS data from sysfs. SMBIOS 3.2 present. Handle 0x1000, DMI type 16, 23 bytes Physical Memory Array Location: System Board Or Motherboard Use: System Memory Error Correction Type: None Maximum Capacity: 128 GB Error Information Handle: Not Provided Number Of Devices: 8 Note dmidecode requires superuser privileges to run. Using dmidecode and the tools mentioned (and more not mentioned) you can extract information about your system and if you combine them with other tools you can use them in scripting to achieve/automate a lot of tasks and things. ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:7:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"Reference Linux Devices \u0026 Hardware (Linux+ Objective 1.1.3) ","date":"2022-08-06","objectID":"/posts/linux-devices-and-hardware/:8:0","tags":["linux","certification","comptia linux+"],"title":"Linux Devices and Hardware","uri":"/posts/linux-devices-and-hardware/"},{"categories":["notes","tutorial"],"content":"CompTIA Linux+ Exam Objective 1.1.2 Info This article is my second note for Shawn Powers’ tutorial playlist on the CompTIA Linux+ Exam. The notes starts here. ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:0:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"UEFI and BIOS UEFI and BIOS are both firmwares on the hardware of the computer that allows the operating system (and other programs) to interface with the motherboard by providing runtime services during the booting process. UEFI stands for Unified Extensible Firmware interface while BIOS means Basic Input/Output System. UEFI was designed to overcome the shortcomings of BIOS especially for more modern hardware. The following summarizes the differences between UEFI and BIOS: UEFI BIOS newer old/legacy uses hard drive partition to store configuration configured and stored in mother board supports drive sizes up to 9 zettabytes supports only up to 2.2 TB drives provides faster boot time than BIOS slower boot time than UEFI offers secure boot less secure than UEFI runs on 32- or 64-bit mode runs on 16-bit mode offers GUI (with mouse navigation) interface keyboard only interface ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:1:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"Boot sources The following are sources from which Linux can boot: hard disk usb devices cd/dvd PXE and iPXE The first three options are the most common boot sources, for instance, booting from the hard drive from which the OS is installed or a bootable usb stick. Pre-boot eXecution Environment (PXE) and iPXE allows you to boot from the network. ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:2:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"GRUB2 The GRand Unified Bootloader (GRUB) is a boot loader that is the first software program that runs when a computer starts. From a casual user standpoint, its purpose is it lets you select where you want to boot to. The GRUB bootloader allows you to boot off the following sources: ISO file memtest other operating systems GRUB2 is the latest iteration of GRUB implementation and is the default version used. ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:3:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"The Boot Process The following diagram illustrates a normal Linux boot process: U B E o I F r O I S i n i t r d v v m m l o l i r i n n u u i x z n i t r a m f s m k o f e d u r u l n l l e e l s Starting with UEFI or BIOS, we go to the GRUB bootloader (assuming we boot off the hard drive normally). GRUB then loads vmlinux. The vmlinux file is a linked executable that contains the Linux kernel. What you’ll typically find however in /boot is its the compressed version vmlinuz which is the case with my computer $ ls -F /boot EFI/ initramfs-linux-fallback.img* intel-ucode.img* grub/ initramfs-linux.img* vmlinuz-linux* Vmlinux is a generic kernel compiled for a multitude of hardware. Because the kernel modules needed for a system is dependent on the specific hardware it has, we need a way to load the kernel modules that a particular system hardware needs. That is where initrd comes in. Initrd is a scheme to load just enough software like kernel modules to recognize the system hardware.Initramfs, an alternative scheme to initrd is a filesystem takes care of mounting important file systems by also loading the proper kernel modules and drivers for the system hardware. ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:4:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"Configuring GRUB The configuration file for grub is located in /boot/grub/grub.cfg but the file you edit is /etc/default/grub. For example, during installation of my system I edited the settings for GRUB_GFXMODE to 1920x1080 screen resolution and set the GRUB_TIMEOUT to 3 so that the GRUB menu disappears faster. After you edit /etc/default/grub, you can then run a command to create the grub configuration which is update-grub or update-grub2 for Ubuntu-based distributions, grub2-mkconfig for RHEL-based distributions, and simply grub-mkconfig for Arch-based distributions. Info Ubuntu’s update-grub/update-grub2 just uses grub-mkconfig or grub2-mkconfig behind the scenes. It should also be noted that there is also a command called grubby for configuring GRUB in RHEL-based distributions. We use command mentioned like so: # for Ubuntu-based distros update-grub # for RHEL-based distros grub2-mkconfig - /boot/grub/grub.cfg ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:5:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"References and Further Reading The Linux Boot Process (Linux+ Objective 1.1.2) UEFI vs BIOS: What’s the Difference? ","date":"2022-08-06","objectID":"/posts/the-linux-boot-process/:6:0","tags":["linux","certification","comptia linux+"],"title":"The Linux Boot Process","uri":"/posts/the-linux-boot-process/"},{"categories":["notes","tutorial"],"content":"CompTIA Linux+ Exam Objective 1.1.1 Info This article is the first of my notes for Shawn Powers’ work-in-progress tutorial playlist on the CompTIA Linux+ Exam. I have already seen his Linux Server Course which I think covers roughly the same topics as his Linux+ playlist will but unfortunately I lost all my hand-written notes for the Linux server course and admittedly I have already forgotten the nitty-gritty of the topics he discussed in the course. And so I’ll be reviewing the topics gradually and take notes as he uploads the videos for the Linux+ series. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:0:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"The Linux Filesystem Standard The abstract of the official documentation for the Linux Filesystem Standard (LFS) says: Abstract This standard consists of a set of requirements and guidelines for file and directory placement under UNIX-like operating systems. The guidelines are intended to support interoperability of applications, system administration tools, development tools, and scripts as well as greater uniformity of documentation for these systems. Simply said, the LFS specifies where certain files go in the file hierarchy of a UNIX-like operating system like Linux. Having a standard like this is important especially since, as the common saying goes, everything in Linux is a file. This is not an exaggeration – everything in Linux is indeed a file; a plain old normal file is a file, a directory/folder is a file, audio is a file, video is a file, even network communication is a file, even hard drives are represented as files and so on. This standard makes filesystems across different Linux installation relatively uniform and so easier to manage for system administrators and even casual users like me who like to hack around the command line. If I run the tree command at the root level / directory of my Linux machine it will show something like this: tree -d -L 1 / / ├── bin ├── boot ├── dev ├── etc ├── home ├── lib ├── mnt ├── opt ├── proc ├── root ├── sbin ├── srv ├── sys ├── tmp ├── usr └── var 16 directories These are the directories under the root level / directory specified in the LFS. Now, let’s go over the purpose of each of them. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:1:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/home and /root The /home directory contains the home directories of the users. For example, a user called foo will have its dedicated /home/foo directory. Found in /home/foo are all the files user foo has like documents, images, media files, etc. Meanwhile, the root user has its own /root home directory which is separate from all the ordinary users of the system. Having /root separate from /home is quite handy especially in case you want to be in single-user mode the root user will still have its configurations. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:2:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/boot In the /boot directory are static files that are needed at sytem boot. The /boot directory of my machine has this files: $ ls -F /boot EFI/ initramfs-linux-fallback.img* intel-ucode.img* grub/ initramfs-linux.img* vmlinuz-linux* Info The -F flag of ls classifies the files it lists using certain markers (one of */=\u003e@|). In the listing above, files appended with / are directories and those appended with * are executables. Here is a brief rundown of the files under my /boot directory: /boot/EFI contains files for UEFI inside /boot/grub are files for the GRUB bootloader the vmlinuz-linux is a (compressed?) statically linked executable file that contains the Linux kernel the initramfs image (along with the kernel) is loaded by the bootloader at boot to start the kernel. intel-ucode.img is the microcode image provided for Intel CPus. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:3:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/etc The /etc (sometimes called et cetera or read as etsy) directory houses (text) configuration files. These files must be static and non-executable. These are the content of my /etc directory (eliding other files to save space): $ ls -F /etc adjtime gtk-2.0/ mkinitcpio.d/ rsyncd.conf alsa/ gtk-3.0/ modprobe.d/ sasl2/ anacrontab healthd.conf modules-load.d/ securetty arch-release host.conf monerod.conf security/ at.deny hostname mpd.conf sensors3.conf audit/ hosts mpv/ sensors.d/ avahi/ i3/ mtab@ services avrdude.conf i3status.conf mtools.conf shadow bash.bash_logout ImageMagick-7/ multipath/ shadow- bash.bashrc initcpio/ named.conf shells bash_completion.d/ inputrc nanorc.pacnew skel/ Some of the configuration files that I recognize are i3/ contains configurations for the i3 window manager mpd.conf is the configuration file for the music player daemon (MPD) ssh/ contains secure shell (SSH) configuration skel/ contains default bash configurations (in my system at least) that will be copied for every users created ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:4:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/opt The /opt directory is reserved for add-on packages. Listing out my /opt directory shows $ ls -F /opt /opt ├── appimages │ └── Sioyek.AppImage Sioyek PDF viewer is an appimage package I installed from the AUR, i.e. not from the official Arch repositories, hence it is installed in /opt. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:5:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/media and /mnt The mount point for removable media devices such as floppy disks and cdrom is /media. While temporarily mounted filesystems are mounted in /mnt. For example, if you have a hard drive attached as /dev/sda you want to copy files from. You can make a directory say /mnt/hddmnt and mount the hard drive in that directory like so mnt /dev/sda1 /mnt/hddmnt. Now you can access (temporarily or as long as the hard drive is mounted) the contents of your hard drive in /mnt/hddmnt as if it were a normal directory in your filesystem. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:6:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/tmp Temporary files that are usually deleted on reboot are stored in /tmp. For example, the cached files (probably produced when I ran the command hugo serve) for Hugo is stored in /tmp/hugo_cache. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:7:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/bin, /sbin, and /lib Essential system binaries and other root-only commands are stored in /sbin (or /usr/sbin and /usr/local/sbin). For example, as specified in the official documentation, the shutdown command (or a symbolic link to it) should be found in /sbin. Essential binaries that may be used by root and users are stored in /bin. For example, the binary for the shell should be found in /bin/sh ( which I symlinked in my computer to /bin/dash) since both the root and users needs to run the shell. The /lib directory contains shared library files needed at boot and required to run the commands stored in /sbin and /bin. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:8:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/dev, /proc, and /sys Hardware represented as files (such as hard drive and com ports) are stored in /dev. For example my primary SSD is represented as /dev/nvme0n1. Process and kernel information generated on the fly are located in /proc. Listing out my /proc directory shows: $ ls -F /proc 1/ 18/ 356744/ 444/ 60/ 71/ 89/ kpagecount 101/ 180/ 358644/ 445/ 614345/ 710057/ 9/ kpageflags 10130/ 181/ 358744/ 446/ 614359/ 711096/ 94/ latency_stats 102/ 182/ 358773/ 447/ 62/ 711843/ 95/ loadavg 102897/ 183/ 358836/ 448/ 63/ 713/ acpi/ locks 102900/ 195/ 359154/ 449/ 64/ 714102/ asound/ meminfo 102904/ 196/ 36/ 45/ 647227/ 715351/ bootconfig misc The numbers are process identifiers (PID) generated on the fly by their respective processes. The command acpi shows battery and other ACPI information from the /proc/acpi (or /sys filesystem) that is again generated on the fly depending on the battery status. The /sys directory contains information about devices, drivers, kernel and other system devices. It overlaps with respect to functionality with the /proc directory and was in fact created to declutter and move over some files from /proc. For example, you may also get battery information from /sys/class/power_supply/BAT0/. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:9:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/var and /var/tmp Files that change or read and write a lot over time are stored in /var. For example, log files are stored in /var/log. A noteworthy subdirectory of /var is /var/tmp where you can store temporary files that are not deleted on reboot in contrast with /tmp. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:10:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"/usr Files that are not necessary for single-user mode are stored in /usr. Most command binaries are stored in /usr/bin. Libraries for most command are stored in /usr/lib. Files and binaries specific to the local Linux system is located in /usr/local and /usr/local/bin, respectively. ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:11:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"},{"categories":["notes","tutorial"],"content":"References and Further Reading Why Linux Puts Files ALL OVER?!?(Linux+ Objective 1.1.1) The Linux Filesystem Standard ","date":"2022-08-05","objectID":"/posts/the-linux-file-hierarchy-structure/:12:0","tags":["linux","certification","comptia linux+"],"title":"The Linux File Hierarchy Structure","uri":"/posts/the-linux-file-hierarchy-structure/"}]